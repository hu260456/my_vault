#### DOS Debug

```Shell
# 查看所有寄存器的内容
r
# 查看并修改寄存器的内容
r <reg_name>
# 查看预设地址的内存
d
# 查看指定地址的内存
d <段地址:偏移地址>
# 查看指定地址范围的内存
d <段地址:偏移地址> <偏移量>
# 修改内存
e <段地址:偏移地址> <数据>
# 询问时修改
# 空格 -> 接受 | 回车 -> 结束
e <段地址:偏移地址>
# 将内存中的机器指令翻译成汇编指令
u <偏移地址>
u <段地址:偏移地址>
# 以汇编指令写入机器指令
# 逐步写入汇编指令
# 回车 -> 结束
a <ENTER>
a <段地址:偏移地址>
# 单步执行
t
# 遇子程序、中断时，直接执行，然后显示结果
p
# 从指定地址处开始，知道遇见断点或程序结束
g(go)
# 退出Debug
q
# jmp
jpm <段地址:偏移地址>
# 仅修改IP
jmp <寄存器>
# loop
# 会改变ip
# 执行前cx一定要赋值
# 1. (cx) = (cx) - 1
# 2-1. 如果cx != 0 -> 转至s
# 2-2. 如果cx == 0 -> 向下执行
loop s
# 附加段寄存器
es
# 定义字型数据
dw 0123H, 0456H, 0789H, ...
# 定义字节数据
db
# 定义一个双字
dd
```

#### CS、IP

```Shell
# CS: 代码段寄存器，作为段地址
# IP: 指令指针寄存器，作为偏移地址
```

#### DS

```Shell
##### 例1
mov bx, 1000H
mov ds, bx # 1000H不能直接送到ds中
mov al, [0] # 将10000H中的数据读到al中
mov al, ds:[0] # 引入段前缀，有些机器编译时可能会把[0]当作常数
##### 例2
mov bx, 1000H
mov ds, bx
mov [0], al # 将al中的数据写到10000H中
```

#### SI、DI

```Shell
# 变址寄存器
# SI: source index, 源变址寄存器
# DI: destination index, 目标变址寄存器
```

#### 栈

```Shell
##### 以字为单位操作
# 将ax中的数据送入栈中
# 执行后： sp = sp - 2
push ax
# 弹栈并送入ax
# 执行后： sp = sp + 2
pop ax
# ss：栈段寄存器 —— 存放栈顶的段地址
# sp: 栈顶指针寄存器 —— 存放栈顶的偏移地址
##### 溢出问题

```

#### 伪指令

```Shell
# segment: 段定义
# end: 汇编程序的结束标记
# assume: 关联段与段寄存器
```

#### 汇编 | 链接

```Shell
# 汇编
masm
masm x(.asm);
# 链接
link x(.obj);
# 执行可执行程序
<可执行文件名>
```

#### 指令

