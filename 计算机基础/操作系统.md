## 操作系统基本概念

### 操作系统的定义

- 控制和管理整个计算机系统的==硬件和软件资源==
- 合理地组织调度计算机的工作和资源分配
- 提供给用户和其他软件方便的接口和环境
- 是计算机系统中最基本的==系统软件==

### 操作系统特征

> 并发和共享为最基本特征，二者互为存在条件

- 并发
	- ==操作系统是伴着多道程序技术出现的，因此，操作系统和程序并发是一起诞生的==
	- 多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，微观上是交替发生的
    - 而并行：两个或多个事件在==同一时刻==发生
    - 单核 CPU 同一时刻只能执行一个程序，各个程序只能并发地执行
    - 多核 CPU 同一时刻可以执行多个程序，多个程序可以并行执行
- 共享
	- 指系统中的资源可供内存中多个并发执行的进程共同使用
	- 两种资源共享方式
	    1. 互斥共享
	        - 同一时刻只允许一个进程访问该资源
	    2. 同时共享==（微观上可能是交替的）==
	        - 同一时间段内允许多个进程同时进行访问
- 虚拟
	- 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，需逻辑上的对应物是用户感受到的
	- ==没有并发性就谈不上虚拟性==
	- 虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续可用大于实际的内存，部分碎片存储在外部磁盘上，在需要时进行交换
	- 虚拟技术
		1. 空分复用技术（虚拟存储器技术）
		2. 时分复用技术（虚拟处理器技术）
- 异步
	- 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进
	- 只有系统有并发性，才有可能导致异步性

### 操作系统发展历程

- **手工操作阶段**
	- 用户独占全机，人机速度矛盾导致资源利用率极低
- **批处理系统**
    1. 单道批处理系统
	    - 引入脱机输入输出技术（用外围机+磁带完成），并由==监督程序==负责控制作业的输入输出
	    - 缓解了一定程度的人机速度矛盾，资源利用率有所提升
	    - 内存中仅能有一道程序运行
	    - CPU 任有大量的时间空闲等待I/0完成，资源利用率依然较低
    2. 多道批处理系统
	    - ==操作系统正式诞生==，用于支持多道程序并发执行
	    - 每次往内存中读入多道程序
	    - ==多道程序并发执行，共享计算机资源==
	    - CPU 和其他资源更能保持忙碌状态，系统吞吐量增大，==资源利用率大幅提升==
	    - 用户响应时间长，没有人机交互功能
	    - 用户提交自已的作业之后就只能等待计算机处理完成，中间不能调试、控制自己的作业执行
- **分时操作系统**
	- 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互
	- 用户请求可以被即时响应，解决了人机交互的问题
	- 用户对计算机的操作相互独立，感受不到别人的存在
	- 对各个用户都是完全公平的，不区分任务的紧急性，不能优先处理一些紧急任务
- **实时操作系统**
    - 能够优先响应紧急任务，某些紧急任务不需要时间片排队
    - 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且==要在严格的时限内处理完事件==
    - 实时操作系统的主要特点是==及时性和可靠性==
    - 分为
	    1. 硬实时系统
			- 必须在绝对严格的规定事件内完成处理，如：导弹控制系统、自动驾驶系统
	    2. 软实时系统
		    - 能接受偶尔违反时间规定，如：12306 火车订票系统
- 其他操作系统
	- 网络操作系统
	- 分布式操作系统
	- 个人计算机操作系统

### 操作系统的功能和目标

- 功能
	- 处理机管理
		- 用于分配和控制处理器
	- 存储器管理
		- 负责内存的分配与回收
	- 设备管理
		- 负责外部设备的分配与操纵
	- 文件管理
		- 负责文件的存取、共享和保护
- 目标
	- 向上层提供方便易用的服务

### 操作系统提供的接口

- 命令接口
    - 联机命令接口
    - 脱机命令接口（批处理命令接口）
- 应用程序接口
    - 可以在程序中进行系统调用（广义指令）来使用程序接口
    - 普通用户不能直接使用程序接口，只能通过程序代码间接使用
- GUI（图形化用户接口）


### 操作系统的运行机制

#### 特权指令与非特权指令

> CPU 在设计和生产的时候就划分了特权指令和非特权指令，因此 CPU 执行一条指令前就能判断出其类型

- 特权指令
	- 指有特权权限的指令，由于这类指令的影响重大，如果使用不当，将导致整个系统崩溃。比如：清空内存、置时钟、分配系统资源、修改虚存的段表和页表，修改用户的访问权限等
- 非特权指令
	- 应用程序只能使用非特权指令，如：加法指令、减法指令等

#### 内核程序与应用程序

- 应用程序
	- 应用程序员写的程序是“应用程序”
- 内核程序
	- 实现操作系统编写的是“内核程序’，由很多内核程序组成了“操作系统内核”，或简称“内核（Kernel)
	- 内核是操作系统最重要最核心的部分，也是最接近硬件的部分

#### 处理机状态

##### 两种状态

> ==为了让 CPU 能够区分此时正在运行的指令是来自内核程序还是应用程序，CPU 被划分成了内核态和用户态==
> ==CPU 中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位用来代表 CPU 当前的状态==

- 内核态（管态）
	- 处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令
	- CPU 可以访问内存中所有数据，包括外围设备，例如硬盘，网卡
	- CPU 也可以将自己从一个程序切换到另一个程序
-  用户态（目态）
	- 处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令
	- 只能受限访问内存，且不允许访问外围设备
	- 占用 CPU 的能力被剥夺，CPU 资源可以被其他程序获取

##### 两种状态的切换

- ==内核态 -> 用户态==
	- 执行一条指令（特权指令），将 PSW 中的标志位改为“用户态”
	- 意味着操作系统主动让出 CPU 使用权
- ==用户态 -> 内核态==
	- 引发一个中断，由硬件自动完成“变态”过程
	- 中断使操作系统夺回 CPU 控制权
	- 引发此中断的事件
		- 系统调用
			- 进程调用：exit、fork
			- 文件系统访问：chmod、chown
			- 设备调用：read、write
			- 信息读取：读取设备信息
			- 通信：mmap、pipe等
		- 异常
			- 执行特权指令等

#### 中断和异常

> ==中断是让操作系统内核夺回 CPU 使用权的唯一途径==
> ==如果没有中断机制，那么一旦应用程序上 CPU 运行，CPU 就会一直运行这个应用程序，就谈不上并发性，就没有操作系统==

##### 中断分类

- 内中断（也称异常）
	- 与当前执行的指令有关，中断信号来源于 CPU 内部
	- 例如
		- 陷入指令（访管指令），==是系统调用实现的原理==
		- 故障（如：缺页故障）
			- ==可能被内核程序修复==
			- 内核程序修复故障后会把 CPU 使用权还给应用程序，让它继续执行下去
		- 终止（如：除零故障、非法使用特权指令）
			- ==由致命错误引起，内核程序无法修复该错误==
			- 因此一般不再将 CPU 使用权还给引发终止的应用程序，而是直接终止该应用程序
- 外中断（狭义的中断）
	- 与当前执行的指令无关，中断信号来源于 CPU 外部
	- 每一个指令周期的末尾，CPU 都会例行检查是否有中断信号
	- 例如
		- 时钟中断
		- IO中断
		- 人工干预

##### 中断基本原理

- 不同的中断信号，需要用不同的中断处理程序来处理
- 当 CPU 检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置
- 中断处理程序是内核程序

#### 系统调用

##### 系统调用的概念

- 系统调用是操作系统提供给应用程序使用的接口，==应用程序可以发出系统调用请求来获得操作系统的服务==
- 系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式
- 应用程序通过系统调用请求操作系统的服务，而系统中的各种共享资源都由操作系统内核统一管理，因此，凡是与共享资源有关的操作（如存储分配、IO操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。==这样可以保证系统的稳定性和安全性，防止用户进行非法操作==

##### 系统调用与库函数的区别

![](attachments/Pasted%20image%2020240629012749.png)

##### 系统调用的过程

1. 传参指令（向寄存器传参，根据系统调用的类型可能有多个参数）
2. 执行陷入指令
3. 引发内中断，程序暂停执行，进入核心态，进入中断处理程序
4. 进入系统调用
5. 返回原程序
6. 

### 操作系统体系结构（内核设计）

#### 内核的基本功能

- 时钟管理
	- 实现计时功能
- 中断处理
	- 负责实现中断机制
- 原语
	- 原语是一种==特殊的程序==
	- ==具有原子性，执行过程一气呵成，不允许被中断==
	- ==运行时间较短、调用频繁==

#### 常见的内核体系结构还包括的功能

- 大内核（或宏内核、单内核）
	- 进程管理
	- 存储器管理
	- 设备管理
	- 对系统资源进行管理的功能
		- 进程管理
		- 存储器管理
		- 设备管理
	- 等等
	- 典型：Linux、Unix
- 微内核
	- 只保留基本功能
	- 性能较差，需要经常在用户态和核心态之间切换
	- 典型：Windows NT
- 分层结构
- 模块化
- *外核*

- *Ubuntu、CentOs 等开发团队主要工作是实现非内核功能，而内核都是用 Linux Kernel*

### 操作系统的引导

#### 磁盘的逻辑划分

- 磁盘
	- 主引导记录 MBR
		- 磁盘引导程序
		- 分区表
	- 活动分区（系统所在的分区，如：Windows 的 C 盘）
		- 引导记录 PBR（负责找到启动管理器，通常在根目录下）
		- 根目录
		- 其他
	- 其他

#### 操作系统引导过程

1. 计算机供电
2. CPU 在主存 ROM 中找到某一特定地址，执行 BIOS 指令（自举程序）
3. BIOS 会先进行硬件自检
4. BIOS 将 MBR 读入内存
5. 执行 MBR 中的磁盘引导程序，磁盘引导程序会扫描分区表，将 PBR 读入内存
6. PBR 程序找到启动管理器
7. 由启动管理器完成操作系统的一系列初始化工作

### 虚拟机

#### 传统机器

- 一台物理机器上只能运行一个操作系统

#### 虚拟机（VM）与虚拟机管理程序（VMM/Hypervisor）

##### 虚拟机

- 使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，每个虚拟机器都可以独立运行一个操作系统
- 没有任何软件支持的计算机称为裸机
- 在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器
- 通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机
- 支持虚拟化的 CPU 通常分更多指令等级
	- ![](attachments/Pasted%20image%2020240629025103.png)

##### 第一类 VMM

- 直接运行在硬件之上，能直接控制和分配物理资源
- 在安装 Guest OS 时，VMM 要在原本的硬盘上自行分配存储空间，类似于"外核"的分配方式，分配未经抽象的物理硬件
- 性能更好
- 操作系统可移植性差
- VMM 运行在内核态最高特权级（RingO），可以执行最高特权的指令
- 各操作系统实际上运行在用户态
- 各操作系统的用户空间分为
	- 虚拟用户空间
	- 虚拟内核空间
- 各操作系统不知道自己处于用户态，依然会使用特权指令
- VMM 会为上层操作系统模拟出它所需要使用的特权指令

##### 第二类 VMM

- 运行在宿主操作系统（Host OS）之上，赖于 Host OS 为其分配物理资源
- Guest OS 拥有自己的虚拟磁盘，该盘实际上是 Host OS 文件系统中的一个大文件；GuestOS分配到的内存是虚拟内存
- 性能更差，需要 Host OS 作为“中介”
- 操作系统可移植性更好，需导出虚拟机镜像文件即可迁移到另一台 Host OS 上，商业化应用更广泛
- VMM 运行在用户态和内核态，Guest OS 发出的系统调用会被 VMM 截获，并转化为 VMM 对 Host OS 的系统调用
- 各操作系统实际上运行在用户态
- 各操作系统的用户空间分为
	- 虚拟用户空间
	- 虚拟内核空间
- 各操作系统不知道自己处于用户态，依然会使用特权指令
- VMM 会为上层操作系统模拟出它所需要使用的特权指令

## 处理机管理

### 进程和程序的概念

- 程序
	- 是==静态==的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合
- 进程
	- ==动态==的，是程序的一次执行过程
	- 同一个程序多次执行会对应多个进程

### 进程的组成

> PCB 是给操作系统用的，程序段和数据段是给用户进程用的

- 程序段
    - 程序的代码（指令序列）
- 数据段
    - 运行过程中产生的各种数据
- PCB
	- 当进程被创建时，操作系统会为该进程分配一个唯一的、“身份证号”-- PID（ProcessID，进程ID）
	- 包含
	    - 进程描述信息
	        - 进程标识符 PID
	        - 用户标识符 UID
	    - 进程控制和管理信息
	        - CPU、磁盘、网络流量使用统计
	        - 进程当前状态：就绪态、阻塞态、运行态
	    - 资源分配清单
	        - 正在使用哪些文件、内存区域、IO 设备
	    - 处理机相关信息
	        - PSW、PC 等各种寄存器的值
	- ==PCB 是进程存在的唯一标志==
    - ==当进程结束时 PCB 会被操作系统回收==

### 进程映像

> 一个进程实体（进程映像）由PCB、程序段、数据段组成
> 进程是动态的，进程实体（进程映像）是静态的
> 进程实体反映了进程在某一时刻的状态
> 进程实体是进程某一时刻的快照

### 进程的特征

- 动态性
	进程是程序的一次执行过程，==是动态地产生、变化和消亡的==
	==是进程的最基本特证==
- 并发性
	内存中有多个进程实体，各进程可并发执行
- 独立性
	进程是能独立运行、独立获得资源的基本单位
- 异步性
	各进程按各自独立的、不可预知的速度向前推进，==操作系统要提供"进程同步机制"来解决异步问题==
- 结构性
	每个进程都会配置一个PCB
	结构上看，进程由程序段、数据段、PCB组成

### 进程的状态

> ==在 PCB 中，会有一个变量用来记录进程当前状态==

- 创建态（新建态）
	- 进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化 PCB
- 就绪态
	- 当进程创建完成后，便进入就绪态
	- 处于就绪态的进程已经具备运行条件但由于没有空闲 CPU，暂时不能运行
	- ==被阻塞的进程获得了所需的资源后会转变为就绪态==
- 运行态
	- 在 CPU 上运行的进程为运行态
- 阻塞态（等待态）
	- 原本的活动进程因为等待资源而被阻塞
	- 操作系统会选择另一个就绪态的进程上处理机运行
- 终止态（结束态）
	-  进程执行 ==`exit`== 系统调用请求操作系统终止该进程，操作系统令该进程==下处理机，回收内存等资源，最后销毁 PCB==
	-  如果运行态进程发生异常也可能进入终止态

### 进程状态的转化

![](attachments/Pasted%20image%2020240627112057.png)

- ==运行态到阻塞态是进程的主动行为==
- ==阻塞态到就绪态是被动行为==
- ==时间片结束或处理机被抢占会导致运行态进入就绪态==
- ==非法的转变==
	- 阻塞态 -> 运行态
	- 就绪态 -> 阻塞态
- 多核系统可能存在多个进程处于运行态

### 进程的组织方式

- 链接方式
	- 按照进程状态将 PCB 分为多个队列
	- 操作系统持有指向各个队列的指针
- 索引方式
	- 根据进程状态的不同，建立几张索引表
	- 操作系统持有指向各个索引表的指针

### 进程控制相关的原语

> 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能

![](attachments/Pasted%20image%2020240629185624.png)

![](attachments/Pasted%20image%2020240629190215.png)

![](attachments/Pasted%20image%2020240629190352.png)

![](attachments/Pasted%20image%2020240629190520.png)

### 处理机调度

>由于资源有限，多个任务无法同时处理，这时需要某种规则来决定处理这些任务的顺序。从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行

#### 调度的三个层次

1. 高级调度（作业调度）
	- 照某种规则，从外存的作业后备队列中选择一个作业调入内存，并为其创建进程
	- 外存 -> 内存
	- 面向作业
	- 发生频率：最低
2. 中级调度（内存调度）
	- 照某种规则，从挂起队列中选择合适的进程将其数据调回内存
	- 外存 -> 内存
	- 面向进程
	- 发生频率：中等
3. 低级调度（处理机调度、进程调度）
	- 按照某种规则，从就绪队列中选择一个进程为其分配处理机
	- 内存 -> CPU
	- 发生频率：最高，==是操作系统中最基本的调度==

#### 进程的调度方式

1. 非抢占式（非剥夺调度方式）
	- 只允许进程主动放弃处理机
	- 在运行过程中即便有更紧急的任务到达，当前进程依旧会继续使用处理机，直到该进程终止或主动要求进入阻塞
	- 实现简单，系统开销小
	- 无法及时处理紧急任务，适合于早期的批处理系统
1. 抢占式（剥夺调度方式）
	- 一个进程正在处理机上执行时，如果有一个更紧急或更重要的需要使用处理机，就立刻暂停正在执行的进程，把处理机分配给更重要紧急的那个进程
	- 可以优先处理更紧急的进程
	- 适合于分时操作系统、实时操作系统

#### 调度算法的评价指标

- $$系统吞吐量 = {{总完成作业数}\over{总花费时间}}$$
- $$利用率_{CPU} = {有效工作时间_{CPU} \over {{（有效工作时间_{CPU} + 空闲时间_{CPU}）}}}={{有效工作时间_{CPU}}\over{CPU总时间_{CPU}}}$$
- $$等待时间 = {{进程}\over{作业等待被服务的时间之和}} = 周转时间 - 运行时间 - 操作时间，由于等待IO也是在被服务，所以等待IO不计入等待时间$$
- $$周转时间 = 作业完成时间 - 作业提交时间 = 高级调度时间 + 总低级调度时间 + 总 CPU 执行时间 + 总等待 IO 时间$$
- $$平均周转时间 = 各作业周转时间和 / 总作业数$$
- $$带权周转时间 = {{周转时间}\over{实际运行时间}} \ge {1}$$
- $$响应时间 = 首次响应时间 - 作业提交时间$$

#### 调度算法

- 先来先服务 FCFS
	- 用于作业调度时，主要考虑哪个作业先到达后备队列
	- 用于进程调度时，主要考虑哪个进程先到达就绪队列
	- 一般是非抢占式的
	- 公平，实现简单
	- 对长作业有利，对短作业不利
	- 不会导致饥饿
- 短作业（进程）优先 SJF/SPF
	- 可用于作业调度，也可用于进程调度
	- 是非抢占式的
	- 有抢占式版本 -- 最短剩余时间优先算法 SRTN
	- 一般可以得到最短的平均等待时间和平均周转时间
	- 对短作业有利，对长作业不利
	- 会导致饥饿
- 高响应比优先算法 HHRN
	- $相应比 = {{等待时间 + 要求服务时间} \over {要求服务时间}} = {周转时间 \over 要求服务时间}$
	- 是非抢占式的
	- 综合考虑了等待时间和运行时间
	- 不会导致饥饿
- 时间片轮转调度算法 RR
	- 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片
	- 用于进程调度
	- 是抢占式的
	- 时间片足够长会退化为 FCFS 算法
	- 适用于分时操作系统
	- 不会导致饥饿
	- 太高频率的进程切换会带来更多系统开销
- 优先级调度算法
	- 为每个作业设置一个优先级
	- 调度时选择优先级最高的作业或进程
	- 有抢占式和非抢占式
	- 优先数越大，优先级越高（具体看题目）
	- 会导致饥饿
- 多级反馈队列调度算法
	- 对其他调度算法的折中权衡
	- 用于进程调度
	- 是抢占式的
	- 如图![[attachments/Pasted image 20240509233927.png]]
	- 会导致饥饿
	- UNIX 使用多级反馈队列调度算法

### 进程通信（IPC）

- 进程间通信是多个进程之间产生数据交互
- 进程是分配系统资源的基本单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立
- 为了保证安全，一个进程不能直接访问另一个进程的地址空间

#### 进程通信方式

- 共享存储
	- 可能发生写冲突
	- 各个进程对共享存储区的访问应该是互斥的
	- 分为
		- ==基于数据结构==的共享
			- 速度慢
			- 是低级共享
		- ==基于存储区==的共享
			- 速度快
			- 是高级共享
	- Linux 系统中通过 `shm_open` 系统调用，申请一片共享内存区，通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间
- 消息传递
	- 进程间的数据交换以格式化的消息（Message）为单位
	- 消息组成
		- 消息头
			- 发送进程 pid, 接收进程 pid, 消息长度等格式化的信息
		- 消息体
			- 消息的具体内容
	- 进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换
	- 分为
		- 直接消息传递
			- 发送进程要指名接收进程
		- 间接消息传递（信箱通信方式）
			- 通过“信箱”间接地通信
- 管道通信
	- 管道通信属于半双工通信
	- ==管道是一种特殊的共享文件==
	- 申请一个管道其实就是内存中开辟一个==大小固定的循环队列缓冲区==
	- 各进程要互斥地访问管道（需要由操作系统实现，而非应用程序）
	- 当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程
	- 当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程
	- 一个管道允许有多个写进程、一个读进程，而 Linux 系统会让多个读进程轮流读取管道

### 进程同步与互斥

- 同步
	- ==同步亦称直接制约关系==
	- ==多个进程因合作产生直接制约关系，使得进程有一定的先后执行关系==
- 互斥
	- ==互斥亦称间接制约关系==
	- 多个进程在同一时刻只有一个进程能进入临界区
- ==临界资源：一次仅允许一个进程使用的共享资源==
- ==临界区：一个访问临界资源的程序片段==
- 信号量
	- 是一个整型变量，它有两个原子操作：P操作（对信号量执行-1操作）和V操作（对信号量执行+1操作），通常在执行这些操作的时候屏蔽中断
	- 如果信号量的取值只能为0或者1，那么就成为了互斥量，0表示临界区已经加锁，1表示临界区解锁
- 设计临界区访问机制的四个原则
	- ==空闲让进==
		- 无进程处于临界区时，可以允许一个请求进入临界区的进程立即进入临界区
	- ==忙则等待==
		- 当临界区忙时，其他试图进入临界区的进程必须等待
	- ==有权等待==
		- 进程进入临界区的请求应在有限时间内得到满足
	- ==让权等待==
		- 当进程无法进入临界区时，应释放处理机，不能忙等

#### ==进程互斥的软件实现方法

- 单标志法
- 双标志先检查
- 双标志后检查
- Peterson 算法

#### ==进程互斥的硬件实现方法==

### 互斥锁



### 信号量机制



### PV 原语

- P 操作
	- S = S - 1
	- 若S减1后仍大于或等于0，则该进程继续执行
	- 若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度
- V 操作
	- S = S + 1
	- 若相加后结果大于0，则进程继续执行
	- 若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度

### 生产者消费者问题

- 俩个或者更多的线程共享同一个缓冲区，其中一个或多个线程作为“生产者”会不断地向缓冲区中添加数据，另一个或者多个线程作为"消费者”，从缓冲区中取走数据
- 缓冲区空时，消费者不能读取数据
- 缓冲区满时，生产者不能添加数据

### 管程

> 每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作会给系统管理带来麻烦，且容易因为同步操作不当而导致系统死锁。于是便产生了一种新的进程同步工具 —— 管程

> Java 中的 synchronized 实现就是类似于管程的机制

- 管程由三部分组成
	- 局部于管程的共享变量说明
	- 对该数据结构进行操作的一组过程
	- 对局部于管程的数据设置初始值的语句，此外还需为管程赋予一个名字

### 进程死锁

> 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进

#### 产生死锁的必要条件

- 互斥条件
	- 只有对必须互斥使用的资源的争抢才会导致死锁
- 不剥夺条件
	- 进程所获得的资源在使用完之前，不能被强行夺走，只能主动释放
- 请求和保持条件
	- 进程已经持有了至少一个资源，但又提出了新的资源的请求，而该资源又被其他进程占有，此时请求资源的进程发生阻塞，且对自己已有资源保持不放
- 循环等待条件
	- 存在一种进程资源的循环等待链
	- 发生死锁时必定有循环等待链，发生循环等待时未必发生死锁

#### 死锁的处理策略

1. 预防死锁
	- 破坏死锁产生的四个必要条件中的一个或多个
		1. 破环互斥条件
			- 基本上行不通，互斥条件很难破环
		2. 破环不剥夺条件
			- 当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说即使某些资源尚未使用完，也需要主动释放从而破坏了不可剥夺条件
		3. 破环请求和保持条件
			- 即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了
		4. 破环循环等待条件
			- 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完
2. 避免死锁
	- 用某种方法防止系统进入不安全状态，从而避免死锁 (银行家算法)
	- 安全状态
		- 系统能按照某种进程推进顺序(P1，P2...Pn)为每个进程分配资源，满足每个进程对资源的最大需求，使每个进程都顺序完成，这就是安全状态
3. 死锁的检测和解除
	- 允许死锁的发生，不过操作系统会负责检测死锁的发生，然后采取某种措施解除死锁
	- 死锁的解除
		- 资源剥夺法
			- 挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程
			- 应防止被挂起的进程长时间得不到资源而饥饿
		- 撤销进程法
			- 制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源
			- 优点是实现简单，但所付出的代价可能会很大，因为有些进程可能已经运行了很长时间
		- 进程回退法
			- 让死锁进程回退到足以避免死锁的地步
			- 这就要求系统要记录进程的历史信息，设置还原点

### 银行家算法

### 线程

- 引入线程后，线程称为程序执行流的最小单位
- 引入线程之后，不仅进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务
- 同一进程的多个线程共享这个进程的PCB、内存空间、硬件资源等
- 线程几乎不拥有系统资源
- 由于共享内存地址空间，同一进程中的线程间通信无需系统干预
- 如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
- 每个线程都有一个 TID、TCB
- 线程也有就绪态、运行态、阻塞态

#### 线程的实现方式

- 用户级线程
	- 操作系统看到的依然是只有进程
	- 由程序员编写的线程库实现多线程并发
	- 这些线程由应用程序管理，而非操作系统
	- 优点
		- 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
	- 缺点
		- 某个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高
		- 尽管在多处理机系统上，一个进程内的所有线程只能共享一个 CPU
- 内核级线程
	- 操作系统的视角可以看到线程
	- 线程的切换需要操作系统参与
	- 优点
		- 当一个线程被阻塞后，其他线程还可以继续执行，并发能力强
		- 多个线程可以在多个处理机上运行
	- 缺点
		- 需要在用户态和核心态之间切换，系统开销大

#### 多线程模型

> 在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型

- 一对一模型
	- 优点
		- 一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行
	- 缺点
		- 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大
- 多对一模型
	- 优点
		- 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
	- 缺点
		- 一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
- 多对多模型
	- 克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞）
	- 又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点

## 内存管理

### 内存管理功能

- 内存空间的分配与回收
	- 由操作系统完成主存储器空间的分配和管理
- 地址转换
	- 将逻辑地址转换成相应的物理地址
- 内存空间的扩充
	- 利用虚拟存储技术或自动覆盖技术，从逻辑上扩充主存
- 存储保护
	- 保证各道作业在各自的存储空间内运行，互不干扰

### 程序变为可在内存中执行的程序需要经过的步骤

- 编译
	- 由编译程序将用户源代码编译成若干目标模块（把高级语言翻译成机器语言）
- 链接
	- 由链接程序将编译后形成的一组目标模块及所需的库函数连接在一起，形成一个完整的装入模块（由目标模块生成装入模块，链接后形成完整的逻辑地址)
- 装入
	- 由装入程序将装入模块装入内存运行，装入后形成物理地址

### 程序链接方式

- 静态链接
	- 程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开
- 装入时动态链接
	- 将各目标模块装入内存时，边装入边链接的链接方式
- 运行时动态链接
	- 在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享

### 程序装入方法

- 绝对装入
	- 程序编译时就知道程序需要放在内存中的什么地方，编译后的程序不是从0开始的逻辑地址，而是真实的物理地址，按照编译程序产生的绝对地址进行装入
- 静态可重定位装入（静态重定位）
	- 编译后的模块需要连续装入内存，但是在内存中的物理地址可与逻辑地址不同，可以存在一定偏移，比如逻辑地址是0-100，它可以在内存中存储在100-200的内存单元中，需要设定一个偏移量就是100，同时也需要为其分配连续的存储空间，不然通过偏移量是无法找到的，可以通过作业的逻辑地址+偏移量获得作业在内存中的绝对地址
- 动态运行时装入（动态重定位）
	- 可以将程序分配到不连续的存储区
	- 将不同的模块可以装入在不同的内存地址，不同模块可以不连续，但是同一模块还是要连续存放的，同一模块需要设定一个重定位寄存器，每个模块的重定位寄存器中的值就是对应的偏移量
	- 装入程序会把模块装入内存，但是并不会立即将装入模块的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正执行时才进行

### 覆盖和交换技术

- 覆盖
	- 将程序分为多个段，常用的段常驻内存，不常用的段在需要时调入内存
	- 打破了必须将一进程的全部信息装入主存后才能运行的限制，解决了程序大小超过物理内存总和的问题
- 交换
	- 内存空间紧张时，系统将内存中的某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存

### 内存碎片

- 内部碎片
	- 配给某进程的内存区域中，有些部分没用上
- 外部碎片
	- 指内存中的某些空闲分区由于太小而难以利用

### 连续分配管理方式

> 连续分配方式是指为一个用户程序分配一个连续的内存空间
> 包括==单一连续分配、固定分区分配和动态分区分配==

#### 单一连续分配

- 内存被分为系统区和用户区
- ![](attachments/Pasted%20image%2020240628011802.png)
- 系统区用于存放操作系统相关数据
- 用户区用于存放用户进程相关数据
- 内存中只能有一道用户程序，用户程序独占整个用户区空间
- 无外部碎片，有内部碎片

#### 固定分区分配

- 将用户内存空间划分为若干固定大小的分区
- 每个分区只装入一道作业，当有空闲分区时，便可再从外存的后备队列中选择适当大小的作业装入该分区
- 固定分区分配分为分区大小相等和分区大小不等两种方式
- ![](attachments/Pasted%20image%2020240628012707.png)
- 无外部碎片，有内部碎片

#### 动态分区分配

>动态分区分配不预先分配内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要
>无内部碎片，有外部碎片

##### 动态分区分配算法

- 首次适应算法
	- 每次都从低地址开始查找，选择第一个能够满足大小的空闲分区
	- 算法开销小，综合性能最好
- 最佳适应算法
	- 将空闲分区按照容量递增链接，每次寻找大小能够满足的第一个空闲分区
	- 优先使用更小的空闲分区
- 最坏适应算法
	- 为了防止留下太多细碎的空闲空间，每次分配时优先使用最大的空闲分区
	- 可以将空闲分区按照容量递减链接
	- 由于每次都使用最大的空闲分区，因此较大的连续分区会很快被利用完，导致大进程到来时可能不足以分配
	- 以减少难以利用的小碎片
- 邻近适应算法
	- 由于首次适应算法每次都从链头开始查找，可能增加查找开销
	- 因此将空闲分区按照地址递增的顺序排成一个循环链表，每次都从上次结束的位置开始查找，使用第一个满足的空闲分区
	- 优点：不用每次都从低地址的小分区开始检索

### 离散分配管理方式

> 如果可以将一个进程分散地装入到若干不相邻的分区中，便可以充分利用内存

#### 基本分页存储的管理方式

##### 页表

- 一个进程对应一张==页表==
- 进程的每一页对应一个==页表项==
- 每个页表项由==页号==和==块号==组成
- 页表记录进程页面和实际存放的内存块之间的对应关系
- 每个页表项的长度是相同的，==页号是隐含的==

##### 基本分页存储

- 将用户进程的地址空间分为与页框大小相等的一个个区域，称为页（页面）
- 每个页面都有一个页号
- 各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中

#### 基本分段存储的管理方式

> 进程的地址空间，按照程序程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址


![](attachments/Pasted%20image%2020240628015332.png)
##### 段表

- 每个段对应一个段表项，其中记录了该段在内存中的起始位置（基址）和段的长度
- 各个段表项的长度相同

##### 基本分段存储

- 进程的地址空间
	- 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址
- 内存分配规则
	- 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

#### 段页式管理方式

> 先分段，再将各段分页
> 再将内存空间分为大小相同的内存块，然后进程内各个分页装入各个内存块中。

### 虚拟存储器

#### 虚拟内存的基本概念

> 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。
> 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
> 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。
> 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。

#### 虚拟内存技术的实现

> ==虚拟内存技术的实现需要建立在离散分配的内存管理方式的基础上==

##### 请求分页存储管理

- 缺页中断
	- 在请求分页存储，每当要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存
	- 此时应将缺页的进程阻塞（调页完成唤醒），若内存中有空闲块，则分配一个块，将要调入的页装入该块
	- 若此时内存中没有空闲块，则要淘汰某页，若被淘汰的页在内存期间被修改过，则要将其写回外存
- 快表
	- 快表就是存放在==高速缓冲存储器==的部分页表
	- 作为页表的Cache，它的作用与页表相似，但是提高了访问速率
	- 由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存
	- ==当快表填满后，又要登记新页时，则需要按照一定替换策略淘汰一个旧的快表项==

##### 请求分段存储管理

##### 请求段页式存储管理

### 页面置换

#### 页面置换算法

- 最佳置换算法 OPT
	- 选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率
	- 操作系统无法提前预判页面访问序列，所以此算法是无法实现的
- 先进先出置换算法 FIFO
	- 每次选择淘汰的页面是最早进入内存的页面
	- Belady 异常
		- 当为进程分配的物理块数增大时，缺页次数不减反增的异常现象
		- 只有 FIFO 算法会产生 Belady 异常
- 最近未使用置换算法 LRU
	- 每次淘汰的页面是内存块中最近的未使用的页面
	- 性能好
	- 实现困难，开销大
- 最近最少使用算法 LFU
	- 
- 时钟置换算法/最近未用算法 CLOCK/NRU
	- 是性能和开销较为均衡的算法
- 改进型的时钟置换算法
	- 

#### 页面抖动

> ==由于系统为进程分配的物理块大小不足、内存驻留的进程太多，刚刚换出到外存的页面马上要调入内存，刚刚调入内存的页面马上由要调出到外存==

## 文件管理

### 文件的属性

- 文件名
	- 同一目录下不允许有重名文件
- 标识符
	- 一个系统内的各文件标识符唯一
- 类型
	- 指明文件的类型
- 位置
	- 文件存放的路径（让用户使用）
	- 在外存中的地址（操作系统使用，对用户不可见)
- 大小
	- 文件的大小
- 创建时间、上次修改时间等
- 文件所有者信息
- 保护信息
	- 对文件进行保护的访问控制信息
- 等等

### 文件的逻辑结构

- 流式文件（无结构文件）
	- 由一系列二进制流或字符流组成
- 记录式文件（有结构文件）
	- 由一组相似的记录组成
		- 根据各条记录的长度，可分为
			- 定长记录
			- 变长记录
	- 分为
		- 顺序文件
			- 文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的
			- ==各个记录在物理上可以顺序存储或链式存储==
			- 分为
				- 串结构
					- 记录之间的顺序与关键字无关
				- 顺序结构
					- 记录之间的顺序按关键字顺序排列
		- 索引文件
			- 建立一张索引表，每个记录对应一个表项
			- 索引表本身就是定长记录的顺序文件
			- 各记录不用保持顺序，方便增加/删除记录
			- 若索引表按关键字顺序排列，则可支持快速检索
			- 索引表可能占用很多空间
		- 索引顺序文件
			- 将记录分组，每组对应一个索引表项
			- 索引顺序文件是索引文件和顺序文件思想的结合
			- 索引顺序文件中，同样会为文件建立一张索引表
			- 不同的是，并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项

### 文件目录

- 文件控制块 FCB
	- FCB 的有序集合称为“文件目录”
	- 目录文件中的一条记录就是一个文件控制块
	- 一个 FCB 就是一个文件目录项
	- 包含
		- 文件的基本信息（文件名、物理地址、逻辑结构、物理结构等）
		- 存取控制信息（是否可读/可写、禁止访问的用户名单等）
		- 使用信息（如文件的建立时间、修改时间等）
		- ==文件名、文件存放的物理地址==
	- FCB 实现了文件名和文件之间的映射，使用户（用户程序）可以实现“按名存取”
- 目录结构
	- 单级目录结构
		- ![](attachments/Pasted%20image%2020240630195510.png)
		- 实现了按名存取，但是不允许文件重名
		- 单级目录结构不适用于多用户操作系统
	- 两级目录结构
		- ==将目录分为主文件目录和用户文件目录==
		- ![](attachments/Pasted%20image%2020240630195909.png)
	- 多级目录结构（树形目录结构）
		- 不同目录下的文件可以重名
		- 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护
		- ==树形结构不便于实现文件的共享==，为此，提出了“无环图目录结构”
	- 无环图目录结构
		- 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图
		- 可以更方便地实现多个用户间的文件共享
		- ==可以用不同的文件名指向同一个文件==，甚至可以指向同一个目录（共享同一目录下的所有内容）
		- 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点
		- 用户提出删除结点的请求时，只是删除该用户的 FCB、并使共享计数器减1，并不会直接删除共享结点
		- 只有共享计数器减为0时，才删除结点
- 索引结点（对文件控制块的优化）
	- ![](attachments/Pasted%20image%2020240630202229.png)

### 文件的物理结构（文件的分配方式）

- 连续分配
	- 连续分配方式要求每个文件在磁盘上占有一组连续的块
	- ==支持顺序访问和随机访问==
	- 文件目录需要记录
		- 起始块号（物理块号 = 起始块号 + 逻辑块号）
		- 文件长度
	- 读取某个磁盘块时，需要移动磁头，因此连续分配的文件在顺序读/写时速度最快
	- 物理上采用连续分配的文件不方便拓展
	- 物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片
	- 可以用紧凑来处理碎片，但是需要耗费很大的时间代价
- 链接分配
	- ==隐式链接==
		- 文件目录需要记录
			- 起始块号
			- 结束块号
		- 除了最后一个磁盘块，各个块都会保存指向下一个块的指针，这些指针对用户是透明的
		- ==支持顺序访问，不支持随机访问==
		- ==不会有碎片问题==，外存利用率高
		- ==方便扩展文件==
		- 查找效率低
	- ==显示链接==
		- 把用于链接文件各物理块的指针显式地存放在一张表中（文件分配表 FAT）
		- ![](attachments/Pasted%20image%2020240630204603.png)
		- 文件目录需要记录
			- 起始块号
		- 一个磁盘仅设置一张 FAT ，开机时，将FAT读入内存，并常驻内存
		- FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的
		- ==逻辑块号转换成物理块号的过程不需要读磁盘操作==
		- ==支持顺序访问和随机访问（相对磁盘来说）==
- 索引分配
