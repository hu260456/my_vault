## 冯诺依曼机

- 以运算器为中心
- 指令和数据用二进制表示
- 指令和数据以同等地位存于存储器，可按地址寻访
- 指令由操作码和地址码组成
- 程序存储在存储器上

## 中央处理器

### 运算器

- 结构
	- ACC
	- MQ
	- X

### 控制器

#### 结构

- CU
    - 集成了 FE, IND, EX, INT
- IR
    - 保存了当前指令，将当前指令的操作码送至 CU
- PC

#### 控制器的设计

#### 硬布线控制器

- 根据 `指令操作码`、`目前的机器周期`、`节拍信号`、`机器状态条件` 即可确定现在这个节拍下应该发出哪些微命令
## 存储器

#### 结构

- 主存
    - 存储体
        - 若干存储单元：存放了一串二进制代码
        - 每个存储单元赋予一个地址
        - 存储单元若干二进制代码的组合成为存储字
        - 存储字长：存储字的长度
            - 存储元件
    - MAR：保存了存储单元的地址/编号
        - MAR的位数和存储单元的个数有关
        - 反映了存储单元的个数
    - MDR：保存了要送到CPU中的数据/从存储体中取出的数据
        - 反映了存储字长

#### 分类

- 按存储介质分类

    - 半导体存储器（如：主存、cache）（易失）

        - TTL逻辑

        - MOS逻辑

    - 磁表面存储器（如：磁盘、磁带，有磁头、载磁体）（非易失）

    - 磁芯存储器（非易失）

    - 光盘存储器（非易失）

- 按存取方式分类

    - 存取时间与物理地址无关（随机访问）

        - 随机存储器RAM

        - 只读存储器ROM

    - 存取时间与物理地址有关（串行访问）

        - 顺序存取存储器SAM：磁带

        - 直接存取存储器DAM：磁盘

- 按在计算机中的作用分类

    - 主存
        - RAM
            - SRAM
            - DRAM
        - ROM
            - 虽然叫 Read-Only-memory，但有些 ROM 是可写的
            - MROM
            - PROM
            - EPROM
            - EEPROM
            - 和 RAM 通常统一编址
    - Flash Memory（闪存）：由 EEPROM 发展而来，写前需擦除，如U盘。另外  SSD 由控制芯片和闪存芯片构成。手机的辅存就是闪存。闪存只由一个 mos 管构成，集成度比 ram 高。
    - 高速缓冲存储器（Cache）: 通常用 SRAM 做
    - 辅存
        - 磁盘、磁带、光盘等

### IO设备

#### 输入输出系统发展概况

- 早期
    - 分散连接
    - CPU和IO设备串行工作
- 接口模块和DMA阶段
    - 总线连接
    - CPU和IO设备并行工作
- 具有通道结构的阶段
- 具有IO处理机的阶段

#### 输入输出系统的组成

- IO软件
    - IO指令
        - 操作码 + 命令码 + 设备码
    - 通道指令
- IO硬件
    - IO接口
    - 设备控制器

#### IO设备与主机的联系方式

- IO设备编址方式
    - 统一编址
        - 用取数、存数指令
    - 不统一编址
        - 有专门的IO指令
- 设备选址
    用设备选择电路识别是否被选中
- 传送方式
    - 串行
    - 并行
- 联络方式
    - 立即响应
    - 异步工作采用应答信号
    - 同步工作采用同步时标

#### IO设备与主机的连接方式

- 辐射式连接：不便于增删设备
- 总线连接

## 总线

### 分类

- 片内总线：芯片内部的总线
- 系统总线（板级总线）：计算机各部件之间的信息传输线

    - 数据总线：双向，与机器字长、存储字长有关
    - 地址总线：单向，与存储地址、IO地址有关
    - 控制总线：有出有入

- 通讯总线：用于计算机系统之间的通信

    - 串行通信总线
    - 并行通信总线

### 总线控制

基本概念

- 主设备：对总线有控制权
- 从设备：响应从主设备发来的总线命令
- 总线判优：确定由哪一个主设备占用总线
    - 集中式
        - 链式查询
        - 计数器定时查询
        - 独立请求
    - 分布式

### 总线标准

TODO
### 总线通信控制

- 目的： 解决通信双方的 `协调配合` 问题
- 总线传输周期

    - 申请分配阶段：主设备申请，总线总裁决定
    - 寻址阶段：主设备向从设备发出 `地址` 和 `命令`
    - 传数阶段：主设备和从设备交换数据
    - 结束阶段：主设备撤销相关信息

### 总线通信的方式

- 同步通信：由 `统一时标` 控制数据传送
- 异步通信：采用 `应答方式`，没有公共时钟标准
- 半同步通信：同步、异步结合
- 分离式通信：充分挖掘系统总线每个瞬间的效能
    - 一个总线传输周期分为
        - 子周期1：主设备申请占用总线，用完后即放弃总线使用权
        - 子周期2：从设备申请占用总线，将数据送到主设备
    - 特点
        - 各模块有权申请占用总线
        - 采用同步方式通信，不等对方回答
        - 各模块准备数据时不占用总线
        - 总线被占用时一定是在传输控制命令或数据，无空闲

## 存储器

### 主存

- 主存的基本组成
- 主存和 CPU 的联系
- 主存中存储单元地址的分配
	- 大端存储
	- 小端存储
- 主存的技术指标
	- 容量
		- 存放的二进制位数
	- 速度
		- 存取时间
		- 存取周期
		- 存储器带宽

### 半导体存储芯片的基本架构

### 内存优化技术

#### 双端口 RAM

- 支持两个 CPU 同时访问一个 RAM

- 禁止两个 CPU 同时写或一读一写

- 若干发生冲突，RAM 应发出 “忙”信号，使其中一个 CPU 的端口暂停访问

#### 多模块存储器

- 多体并行存储器
	- 地址由体号和体内地址构成
	- 分为
		- 高位交叉编址，体号在地址高位
		- 低位交叉编址，体号在地址低位
			- 当存储模块数 m ≥ T/r 时，可以使流水线不间断
			- 两个实现低位交叉的多体存储器就是俗称的“双通道”
			- 实现双通道需要两根相同主频（否则多出来的主频会被降频，相当于浪费了其中一根内存条的部分性能）、相同容量的内存条
			- 如果两个内存条插到了不支持双通道的插槽上，相当于单纯的扩容
			- 一般 2 根 8 GB 的内存条性能比 1 根 16 GB 的内存条更好
	- 单体多字存储器
		- 每次并行读出 n 个连续的字
		- 总线宽度也要扩展为 n 个字
	### 增加主存的存储字数

	- 位扩展：可以增加存储器的字长

	- 字扩展：可以增加存储器的存储字数

		- 线选法：n 条线 → n 个片选信号，电路简单，地址空间不连续

		- 译码片选法：n 条线 → 2^n 个片选信号，电路复杂，地址空间可连续，实际应用选择片选法

	- 字位同时扩展

	### 辅存

	- 磁盘

		- 一块硬盘含有若干个记录面（每个记录面对应一个磁头），每个记录面划分为若干磁道，每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位，也就是说磁盘按块存取

		- 柱面：不同记录面相同编号的磁道构成一个圆柱面，一个盘面有多少条磁道，这个存储器就有多少个柱面

		- 磁盘所有磁道记录的信息量都相同，所以同一个记录面每个磁道位密度不同

		- 性能指标

			- 容量

			- 记录密度

				- 道密度

				- 位密度

				- 面密度 = 道密度 * 位密度

			- 平均存取时间

				- = 寻道时间（磁头移动到目的磁道）

				- +旋转延迟时间（磁头定位到目的扇区）

				- +传输时间（传输数据所花费的时间）

		- 磁盘地址

			- 驱动器号：一台电脑可能有多个硬盘

			- 柱面（磁道）号：移动磁头臂寻道

			- 盘面号：激活某个磁头

			- 扇区号：通过旋转盘面特定扇区将经过磁头下方

		- 磁盘的读写操作是串行的，且同一时刻不可同时读或写，也不能在同一时刻读两组数据或写两组数据

		- 磁盘阵列

	- 固态硬盘

		- 原理：基于闪存技术，属于 EEPROM

		- 组成

			- 闪存翻译层: 负责翻译 系统通过 IO 总线发送的逻辑块号

				- 一个逻辑地址所映射到的物理地址可能会被闪存翻译层改变

			- 存储介质: 多个闪存芯片，每个芯片包含多个块，每个块包含多个页

		- 读写性能:

			- SSD 的读写是以页为单位的

			- SSD 的擦除是以块为单位的

		- 与机械硬盘相比

			- SSD 的一个块被擦除次数过多可能会坏掉，而 HHD 的扇区不会因为写的次数过多而坏掉

		- 磨损均衡技术

			- 动态磨损均衡

				- 写入数据时，优先选择累计擦除次数少的块

			- 静态磨损均衡

				- SSD 监测并自动进行数据分配、迁移，让老旧的块承担以读为主的任务，让较新的块承担更多的写任务

	- Cache

		- 用于缓和 CPU 和主存速度的矛盾

		- Cache 用 SRAM 实现，速度快，成本高，集成度比 DRAM 低

		- 实际上，现代 Cache 通常集成在 CPU 内

		- 每次被访问的主存块一定会被立即调入 Cache

		- 局部性原理

			- 空间局部性：在最近的未来要用到的数据或指令，很可能与现在正在使用的数据或指令在存储空间上是邻近的

				- 如何界定“邻近”？

					- 将主存的空间分块，主存与 Cache 之间以块为单位进行数据交换

					- 可以给主存的各个块进行编号

					- 主存地址可以看作由块号和块内地址组成

					- 操作系统中通常将块称作页/页面/页框

					- Cache 中的块也称为行，Cache 块号也成称为行号

			- 时间局部性：在最近的未来要使用的信息很可能是现在正在使用的信息

		- 性能分析

			- 命中率 H：CPU 欲访问的信息已在 Cache 中的比率

			- 缺失率 M：1 - H

			- 设 Cache - 主存平均访问时间为 t，tc 为 CPU - Cache 访问耗时，tm 为 CPU - 主存 访问耗时

				- 若 CPU 先访问 Cache， 未命中再访问主存

					- t = Htc + (1 - H)(tc + tm)

				- 若同时访问 Cahce 和主存，Cache命中则停止访问主存

					- t = Htc + (1 - H)tm

		- Cache 和主存的映射方式

			- 全相联映射

				- 主存块可以放在 Cache 的任何位置

				- Cache 需要标记一位有效位与对应的主存块号

				- 优缺点

					- 命中率高

					- 查找标记最慢

			- 直接映射

				- 每个主存块只能放到一个特定的位置

				- Cache块号 =  主存块号 % Cache总块数

				- Cache 需要标记以为有效位与对应的主存块号

				- 若 Cache 总块数为 2^n，则主存块号末尾 n 位直接反映它在 Cache 中的位置

				- 优缺点

					- 速度最快

					- 命中率低

			- 组相联映射

				- Cache 块分为若干组，每个主存块可放到特定分组中的任意一个位置

				- 组号 = 主存块号 % 分组数

				- 术语：n 路组相联映射

					- 每 n 个 Cache 行为一组

				- 优点

					- 另外两种方式的折中，综合效果好

		- 替换算法 

			- 替换算法只会用到全相联映射和组相联映射，直接映射无需考虑替换算法

			- 四个替换算法

				- 随机算法(RAND)

					- 若 Cache 已满，则随机选择一块替换

					- 实现简单，没完全考虑局部性原理

					- 命中率低，实际效果很不稳定

				- 先进先出算法(FIFO)

					- 若 Cache 已满，则替换最先被调入 Cache 的块

					- 实现简单，但依然没考虑局部性原理，实际效果依然不理想

					- 抖动现象：刚被替换的块很快又被调入

				- 近期最少使用算法(LRU)

					- 为每个 Cache 块设置一个计数器用于记录块多久没有被访问，当 Cache 块满后替换计数器最大的

					- Cache 块的总数为 2^n，则计数器只需 n 位

					- Cache 装满后计数器的值一定不重复

					- 基于时间局部性原理，实际效果优秀，Cache 命中率高

					- 若被频繁访问的主存块数量 > Cache行数量，可能发生抖动现象

				- 最不经常使用算法(LFU)

					- 为每个 Cache 块设置一个计数器，用于记录每个 Cache 块被访问过的次数，当 Cache 块满后替换计数器最小的

					- 当两 Cache 块计数器相等，可按行号递增或 FIFO 策略进行选择

					- 曾经被经常访问的块在未来不一定会用到，LFU算法并没有很好地遵循局部性原理，因此实际效果不如LRU

		- Cache 写策略: 解决 Cache 和 主存中数据一致性问题，读时不存在此问题

			- 写命中

				- 全写法(写直通法)

					- CPU 对 Cache 写命中时，同时写入 Cache 和主存

					- 访存次数增加，速度变慢，但更能保证数据一致性

					- 写缓冲: SRAM 实现的队列

						- CPU 对 Cache 写命中时，同时写如 Cache 和写缓冲

						- 使用一个专门的控制电路逐一写回主存

					- 使用写缓冲，CPU 写的速度很快，若写的操作不频繁，则效果很好；若写操作很频繁，仍然会因为写缓冲饱和而发生阻塞

				- 写回法

					- CPU 对 Cache 写命中时，只修改 Cache 的内容，不写主存

					- 为每个 Cache 行增加一位“脏位”，当写命中时，脏位为 1

					- 被替换的块脏位为 1 时写回主存

					- 减少了访存次数，但存在数据不一致的隐患

			- 写不命中

				- 写分配法

					- 写不命中，CPU 先把主存块调入 Cache，再对 Cache 进行写操作

					- 通常搭配写回法

				- 非写分配法

					- 当 CPU 写不命中时，直接写入主存，不调入 Cache

					- 通常搭配全写法

		- 多级 Cache

			- 现代计算机常采用多级 Cache

			- 离 CPU 越近的速度越快，容量越小

			- L1 缓存中保存的是 L2 缓存中的副本

			- 多级缓存之间同样存在数据一致性问题

			- Cache之间常采用全写法 + 非写分配法

			- Cache 与主存之间常采用写回法 + 写分配法

### 页式存储器

- 一个程序被分为多个页，每个页面的大小和主存一个物理块的大小相同

- 给程序分页是操作系统做的事情

- 页面存储系统: 一个程序（进程）在逻辑上被分为若干个大小相等的“页面”

- 每个页面可以离散地放入不同的主存块中

- 逻辑地址(虚地址): 程序员视角看到的地址

- 逻辑地址由逻辑页号和页内地址组成

- 物理地址(实地址): 实际在主存中的地址

- 为了记录逻辑页号到主存块号之间的映射关系，操作系统会建立一张页表

- CPU 里会有一个页表基址寄存器，指明了页表的基地址

- 通过查询页表，将主存块号和页内地址进行拼接就可以得到物理地址

- 页表是存储在主存里的

- 页表中的一行称作一个页表项，每个页表项代表一个逻辑页号和一个主存块号之间的映射

- 快表(TLB)

    - 引入快表是为了加快从逻辑地址到物理地址的映射

    - 快表使用 SRAM

    - 快表是一种相联存储器(CPU 可以根据内容寻访)

    - CPU 对快表的查询速度非常快

    - 引入快表是为了减少访存

    - 引入快表后，页表可以称为慢表

    - 访问某个逻辑地址时，CPU 会首先在快表中查询逻辑页号所对应的主存块号，若不命中才在主存中查询慢表

### 虚拟存储器

- 页式虚拟存储器

    - 将外存中的程序拆分成一个一个大小相同的页面，以页面为单位来决定需要把那些页面调入主存

    - 虚拟地址 = 页号 + 页内地址

    - 页面替换

        页面替换算法也可以用 LRU、FIFO 等替换算法

- ​段式虚拟存储器

    - 将外存中的程序按照功能模块分段，操作系统会决定把哪些段调入主存

    - 虚拟地址 = 段号 + 段内地址

    - 为了完成虚拟地址到物理地址的转换，需要记录每个段在主存中的起始地址

- 段页式虚拟存储器

    - 先把一个程序分段，再进行分页

## 指令系统

- 指令周期

    - 取指 (FE=1)

        PC 具有计数功能，保存了欲执行的指令的地址

    - 间指 (IND=1)

    - 执行 (EX=1)

    - 中断 (INT=1)

- 指令是计算机执运行的最小功能单位

- 一台计算机所有指令的集合构成该机的指令系统，也称`指令集`

- 一台计算机只能使用自己的指令系统

- X86、ARM 两种架构支持的指令集不一样，所以这两个平台的程序不能运行在对方上

### 指令格式

- 按照地址码数量分类

    - 零地址指令

        不需要操作数，如空操作、停机、关中断等指令

        对于堆栈计算机，两个操作数隐含在栈顶和次栈顶，计算结果压回栈顶。如堆栈型计算机进行算数运算的时候通常就是基于“后缀表达式”来进行运算的

    - 一地址指令

        - 需要一个操作数，如自增、自减、取反、求补

            完成一条指令需要 3 次访存：取指 → 读 → 写回

        - 需要两个操作数，其中一个操作数隐含在某个寄存器(如ACC)

            完成一条指令需要两次访存：取指 → 读

    - 二地址指令

        完成一条指令需要访存 4 次：取指 → 读A1 → 读A2 → 写回A1

    - 三地址指令

        完成一条指令需要访存 4 次：取指 → 读A1 → 读A2 → 写 A3

    - 四地址指令

        完成一条指令需要访存 4 次：取指 → 读A1 → 读A2 → 写A3

        执行指令后，将 PC 的值修改为 A4 所指向的地址

- 按指令长度分类

    有：

    - 半字长指令：指令长度是机器字长的一般

    - 单字长指令：指令字长和机器字长相等

    - 双字长指令：指令字长是机器字长的两倍，一次取指需要两次访存

    指令字结构:

    - 定长指令字结构：指令系统中所有指令的长度都相等

    - 变长指令字结构：指令系统中素有指令的长度不相等

- 按操作码长度分类

    - 定长操作码：指令系统中所有指令的操作码长度都相同

        控制器的译码电路设计简单，但灵活性较低

    - 可变长操作码：指令系统中各指令的操作码长度可变

        控制器的译码电路设计较复杂，但灵活性较高

- 按操作类型分类

    - 数据传送类: 进行主存与 CPU 之间的数据传送

        - 数据传送

            LOAD: 把存储器中的数据放到寄存器中

            STORE: 把寄存器中的数据放到存储器中

    - 运算类

        - 算术逻辑操作

            算数与逻辑运算

        - 移位操作

            算术移位、逻辑移位、循环移位

    - 程序控制类: 改变程序执行的顺序

        - 转移操作

            无条件转移 JMP

            条件转移 JZ：结果为 0，JO：结果溢出，JC：结果有进位

            调用和返回 CALL 和 RETURN

            陷阱与陷阱指令

        - 输入输出操作

            CPU 寄存器与 IO 端口(IO接口中的寄存器)之间的数据传送

### 扩展操作码（不定长操作码）

- 采用定长指令字结构 + 可变长操作码

- 一种扩展操作码指令格式的举例

    - 指令字长 16 位，每个地址码 4 位

    - 非 1111 开头的是 三地址指令

    - 1111 开头的是 二地址指令

    - 1111 1111 开头的是 一地址指令

    - 1111 1111 1111 开头的是零地址指令

- 设计扩展操作码指令格式时

    - 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分相同

    - 各指令的操作码一定不能重复

    - 通常为使用频率较高的指令分配较短的操作码

- 优缺点

    在指令字长有限的前提下仍保持比较丰富的指令种类，但增加了指令译码和分析的难度，使控制器的设计复杂化

### 指令寻址

`CPU 要执行的下一条指令始终由 PC 给出`

- 顺序寻址

    PC + "1" → PC，此处的 "1" 理解为指令字长

- 跳跃寻址

### 数据寻址

`任务：确定本条指令的地址码指明的真实地址`

寻址特征：有十种，所以用 4 个比特位表示

本例中形式地址标记为 A，有效地址为 EA，`假设指令字长 = 机器字长 = 存储字长`

一地址指令 = 操作码 + 寻址特征 + 形式地址

多地址指令 = 操作码 + n * (寻址特征 + 形式地址)

- 隐含寻址 0000

    - 在指令中隐含着操作数的地址

    - 优点：有利于缩短指令字字长

    - 缺点：需增加存储操作数或隐含硬件地址的硬件

- 立即寻址 0001

    - A 就是操作数本身，又称为立即数，一般采用补码形式

    - ‘#’表示立即寻址

    - 取指令访存一次，执行指令不访存

    - 优点：执行指令阶段不访存，不访问寄存器，指令执行时间最短

    - 缺点：A 的位数限制了立即数的范围

- 直接寻址 0010

    - 指令字中给出的 A 就是 EA

    - 优点：简单，指令执行阶段仅需一次访存，不需专门计算操作数的地址

    - 缺点：操作数的地址不易修改

- 间接寻址 0011

    - 一次间接寻址：EA = (A)

    - 还可以有多次间接寻址

    - 优点：可扩大寻址范围；便于编程

    - 缺点：指令在执行阶段需要多次寻址

- 寄存器寻址 0100

    - 指令字给出的地址码不指向某一个存储单元，而指向一个寄存器

    - 只需要在取指令的时候进行一次访存

    - 优点：速度快

    - 缺点：寄存器有限，价格昂贵

- 寄存器间接寻址 0101

    - 寄存器给出的不是一个操作数，而是操作数所在主存单元的地址，即 EA = (R)

    - 取指令需要一次访存，执行指令时也需要一次访存

- 相对寻址 0110

    - 属于“偏移寻址”

    - 以 PC 所指地址作为起点

    - EA = (PC) + A

- 基址寻址 0111

    - 属于“偏移寻址”

    - 以程序的起始存放位置作为起点

    - 基址寄存器(BR)

    - EA = (BR) + A

    - 作用

        将 CPU 中基址寄存器(BR)的内容加上指令格式中的 A，形成操作数的有效地址

    - 程序运行前，CPU 将 BR 的值修改为该程序的起始地址（存在操作系统 PCB 中）

    - `BR 是面向操作系统的`，其内容由操作系统或管理程序确定，程序员不能修改。程序执行过程中 BR 的内容不变

    - 但采用通用寄存器作为 BR 时，可由程序员决定哪个寄存器作为 BR，但其内容仍由操作系统决定

- 变址寻址 1000

    - 属于“偏移寻址”

    - 程序员自己决定哪里作为起点

    - 变址寄存器(IX, index register)

    - `IX 是面向用户的`，程序执行过程中，IX 中的内容可由用户改变

- 堆栈寻址 1001

    - 操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址

    - 硬堆栈：使用专门的寄存器实现堆栈

    - 软堆栈（实际通常采用）：堆栈存储在主存中，SP 指向栈顶

### 高级语言的机器级表示

#### 分支语句

```Plain Text
cmp a, b  # 比较 a 和 b 两个数，a 和 b 也可以来自寄存器、主存
jg <addr>
```

|条件转移指令|备注|
|-|-|
|je <addr>|jump when equal|
|jne <addr>|jump when not equal|
|jg <addr>|jump when greater than|
|jge <addr>|jump when greater than or equal to|
|jl <addr>|jump when less than|
|jle <addr>|jump when less than or equal to|

#### 循环语句

```Plain Text
# 可以使用 jmp 或 loop 实现循环，以下是 loop 实现的循环语句
mov ecx, 100  # 只能用 ecx, 不能用 eax 等，因为 loop 指令只能自动减 ecx 这个寄存器
Looptop:
...  # 要循环的内容
loop Looptop  # ecx--, 若 ecx != 0, 跳转到 Looptop
```

|补充指令|备注|
|-|-|
|loopz|当 ecx ≠ 0 && ZF == 1 时，继续循环|
|loopnz|当 ecx ≠ 0 && ZF == 0 时，继续循环|

#### 函数调用

- 函数调用指令：`call`

- 函数返回指令：`ret`

- x86中 `push` 和 `pop` 指令默认以 `4字节` 为单位

- 调用栈栈底在高地址，栈顶在低地址

- `call` 和 `ret` 都会改变 PC 的指向

- `call`指令的作用

    - 将 `IP` 旧值压栈保存

    - 设置 `IP` 新值，无条件转移至被调用函数的第一条指令

- `ret` 指令的作用

    - 从栈顶找到 `ip` 旧值，将其出栈并恢复 `ip`

- 保存栈帧：发生函数调用或函数返回时，需要修改 `ebp` 和 `esp`

    ```Plain Text
    # 被调用函数的前两行代码：
    push ebp
    mov ebp, esp
    # 可以用 enter 指令替代
    # 函数返回前执行：
    mov esp, ebp
    pop ebp
    # 可以用 leave 指令替代
    ```

- 栈帧包含的内容

    - 栈帧最底部一定保存了上一层栈帧基地址（ebp旧值）

    - 通常将局部变量集中存储在栈帧底部区域

    - C语言中越先定义的局部变量越靠近栈顶

    - 参数列表中越靠前的越靠近栈顶

    - GCC 将每个栈帧大小设置为 16B 的整数倍（当前函数的栈帧除外），因此栈内可能出现空闲未使用的区域

### 常用的 X86 汇编指令

`d 代表源操作数，s 代表目的操作数，目的操作数不可以是常量，运算结果将存回 d`

`操作数可以来自寄存器、主存或指令里`

`不允许两个操作数同时来自主存`

`写汇编代码时，通常会以函数名作为“标号”，标注该函数指令的起始地址`

Intel x86格式

|指令|功能|备注|
|-|-|-|
|add d, s|加||
|sub d, s|减||
|mul d, s|两个无符号数乘||
|imul d, s|两个有符号数乘||
|div s|无符号数除法|进行除法前，需要将被除数进行位扩展，存在edx:eax两个寄存器中再进行除法运算，计算结果商存入 eax, 余数存入 edx。|
|idiv s|有符号数除法|进行除法前，需要将被除数进行位扩展，存在edx:eax两个寄存器中再进行除法运算，计算结果商存入 eax, 余数存入 edx。|
|neg d|取负数||
|inc d|自增||
|dec d|自减||
|and d, s|与||
|or d, s|或||
|not d|非||
|xor d, s|异或||
|shl d, s|左移||
|shr d, s|右移||

#### x86 架构的寄存器

`如果寄存器以 e 开头，它长度为 32bit`

`变址寄存器 SI、DI`

`堆栈基指针 EBP（指向栈底），堆栈顶指针 ESP（指向栈顶）`

`只有通用寄存器可以拆开（如AX、AH、AL）使用`

### Intel x86 格式和 AT&T 格式的区别

||AT&T|Intel|
|-|-|-|
|目的操作数d、源操作数s|op s, d|op d, s|
|寄存器的表示|mov %ebx, %eax|mov eax, ebx|
|立即数的表示|mov $985, %eax|mov eax, 985|
|主存地址的表示|mov %eax, (af996h)|mov [af996h], eax|
|读写长度的表示|movb $5, (af996h)|mov byte ptr [af996h], 5|
|-|movw $5, (af996h)|mov word ptr [af996h], 5|
|-|movl $5, (af996h)|mov dword ptr [af996h], 5|
|-|addb $4, (af996h)|add byte ptr [af996h], 4|
|主存地址偏移量的表示|movl -8(%ebx), %eax|mov eax, [ebx - 8]|
|-|movl 4(%ebx, %ecx, 32), %eax|mov eax, [ebx + ecx*32 + 4]|

### CISC | RISC

- CISC

    绝大多数为微程序控制

- RISC

    指令字长是固定的

    只有 LOAD 和 STORE 指令可以访存

    通用寄存器较多

    绝大多数为组合逻辑控制

