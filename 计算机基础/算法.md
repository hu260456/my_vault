### 算法的基本要点

- 必须具备的特性
    - 有穷性：算法必须是 `有穷的`，而程序可以是 `无穷的`
    - 确定性：同一个的输入对应一个相同的输出
    - 可行性：算法可以通过基本运算执行有限次实现
    - 可没有输入
    - 必须有输出
- 应尽可能具备的特性
    - 正确性
    - 可读性
    - 健壮性
    - 高效率、低内存
- 算法评估
    - 角度
        - 时间
        - 空间
    - 方法
        - 事后统计
        - 事前分析
            - 时间复杂度 T(n)
            - 渐近时间复杂度 O(n)
            - 空间复杂度 S(n)
            - 渐进空间复杂度 O(n)
### 查找

- 算法评价指标
    - 查找长度
        查找运算中，需要对比关键的次数
    - 平均查找长度(ASL)
        所有查找过程中进行关键字的比较次数的平均值
- 分类
    - 顺序查找(线性查找)
    - 二分查找(折半查找)
        适用于 `有序的顺序表`
    - 分块查找
    - 散列查找
### 排序

- 交换排序
    - 冒泡排序
	    - `稳定`
    - 快速排序
	    - `不稳定`
	    - 适合大部元素无序的情况
        - 待排序表中任选一个元素作为枢轴pivot
        - 每一次划分都使pivot左边的元素小于pivot，右边的大于pivot
	    - 每一次划分都使pivot元素确定最终位置
        - 优化pivot
	        - 选择首、中、尾三个元素的中位数作为pivot
	        - 选择随机元素作为pivot
- 选择排序
    - 简单选择排序
	    - `不稳定`
    - 堆排序
	    - `不稳定`
- 插入排序
    - 直接插入排序
	    - `稳定`
    - 折半插入排序
	    - `稳定`
        - 插入时折半查找插入位置
        - 只减少了查找次数，没有减少移动元素的次数，TC不变
    - 希尔排序
	    - `不稳定`
        - 先追求部分有序，再追求全局有序
        - TC 比较复杂，与 gap 有关
- 归并排序
	- `稳定`
- 广义的桶排序
    - 计数排序
	    - `稳定`
        - 适用于关键字多但是取值范围小的情况
    - 桶排序
        - 根据元素的取值范围划分桶
        - 使得各个桶有序后取出的元素整体有序
    - 基数排序
	    - `稳定`
        - 从个位到最高位，对每个位都做一次分配、收集
        - 适用于每个关键字都可以拆分成 d 元组的序列
- 外部排序
    - 使用归并排序的思想
    - 内存中最少需要1块输出缓冲区，m(归并路数) 块输入缓冲区
    - 缓冲区大小同一个磁盘块一样
    - 每当一个缓冲区空了，就需要装满
    - 做 k 路归并，则归并树可以用 k 叉树表示
- 败者树
- 置换选择排序

### 差分

- 差分是前缀和的逆运算
- 对差分数组进行前缀和可以得到原数组
- 如果需要对原数组连续进行多次区间修改最后再获得结果，可以使用差分算法
    1. 设 m 为原数组，n 为差分数组
    3. 开始多次修改，若区间为 `[i, j)，变化量为 t，n[i] += t, n[j] -= t`
    4. 最后根据差分数组计算原数组
### KMP 算法

- TC = O(m+n)
- 前缀表右移一位，第一位为 -1，获得 next 数组
- 求 next 数组步骤
    1. 求得前缀表（最长公共真前后缀（不能是整个串）表）
    2. 例如："aabaaf"
    3. a → 0
    4. aa → 1
    5. aab → 0
    6. aaba → 1
    7. aabaa → 2
    8. aabaaf → 0
    9. 所以 "aabaaf" 的前缀表是 0, 1, 0, 1, 2, 0
    10. 所以，next 数组是：-1, 0, 1, 0, 1, 2

### 扩展 KMP 算法

- 也称 `Z 算法`
- 从字符串 s 出发, 最多能匹配字符串中多少个字符

### AC 自动机

- 用于敏感词过滤
- 属于多模匹配算法 (多个模式串匹配一个主串)
- AC自动机的关键要素
    - Trie树
    - fail指针
        - root 结点的 fail 指向自身
        - **层序遍历**创建每个结点的 fail
        - 设遍历到值为 'a' 的结点 A:
            - 如果 A 的父亲的 fail 结点下存在值为 'a' 的结点 A2，A 的 fail 指向 A2
                - 如果 A 和 A2 都是结束位置，A2 的长度数组需要添加到 A 中
            - 如果 A 的父亲的 fail 结点下不存在值为 'a' 的结点 A2，A 指向 root
- 匹配敏感词
    - 第 n 次匹配到的敏感词的长度为长度数组 `arr[n - 1]`
    - 开始第 2 次匹配时，回溯 `arr[1]` 个单位

### 质数的判断与筛法

- 单点判断
    - 判断 x 是否是质数，可以枚举 (1, $\sqrt{x}$] 之间是否存在因子
- 埃氏筛
    - 对于任意 x > 1, 2x, 3x..., nx 都是合数，可以筛掉
    - 使用质数作为筛选因子，因为合数的因子已经筛过它后面的数了
    - 当 x 作为筛选因子时，从 $x^2$ 开始筛选
    - 筛选因子 * 筛选因子 ≥ range 时，不必继续筛选
- 欧拉筛（线性筛）
	- 每个合数一定是被它的最小质因子筛掉
### GCD 与 LCM

- 求两个数的 GCD
	- 辗转相除法
- 求两个数的 LCM
	- `lcm(a, b) = a / gcd(a, b) * b `

### 位运算

```CPP
// 获得 n 的最低位
int least_bit = n & 1;

// 返回下一个满足 n == 2 ^ n 的数，例如给定 00101011， 返回 01000000
// 如果是 8 位
n |= n >> 1;
n |= n >> 2;
n |= n >> 4;
// 获得 n = 00111111
return n + 1;

// 获取一个非负数最低位1代表的值
inline int lowbit(int x) {
	return x & (-x);
}

// 判断一个数是不是 2 的幂一
inline bool isPowerOfTwo(int x) {
	return lowbit(x) == x;
}

// 判断一个数是不是 2 的幂二
inline bool is_power_of_2(int n) {  
    return !(n & (n - 1));  
}

// 判断一个数是不是 4 的幂
inline bool isPowerOfFour(int x) {
	if (x < 0)
		return false;
	if (!isPowerOfTwo(x))
		return false;
	return (n & 0xaaaaaaaa) == 0;
}
```

### 后缀数组

- 把字符串的所有后缀按字典序排序
- 例如字符串 "abccbac"
	- 所有后缀
		1. abccbac
		2. bccbac
		3. ccbac
		4. cbac
		5. bac
		6. ac
		7. c
	- 后缀数组 sa\[i] 表示的是排名为 i 的是什么
		1. abccbac = 1
		2. ac = 6
		3. bac = 5
		4. bccbac = 2
		5. c = 7
		6. cbac = 4
		7. ccbac = 3
	- rak\[i] 询问的是第 i 个的排名是什么
		- rak\[3] = 6
- 如何求解 sa
- LCP(i, j) 表示 sa\[i] 与 sa\[j] 的最长公共前缀
- height\[i] 表示 LCP(i, i - 1)

### 字符串哈希

- 常用的字符串哈希函数：H(s) = $\sum_{i=1}^{n}{s[i]}\cdot{p^{i-1}}\mod M$
- p 与 M 互质，M 通常取 UINT_64
- p 通常取质数 131, 1331, 13331
- 例如对于 s = "abc", $H(s) = 97\times131^2 + 98\times131 + 99$
- 求一个字符串的哈希值相当于求前缀和
	- 对于前缀哈希值 h\[i], $h[i] = h[i-1] \times p + s[i]$
- 求一个字符串的子串的哈希值相当于求区间和
	- 对于子串哈希值 `h[l, r]`, $h[l, r] = h[r] - h[l - 1] \times p^{r-l + 1}$

### manacher 算法

- 用于查找最长回文子串
- 是中心扩散法的改良
- 扩展字符不一定是 '#'，可以是任意字符
- 真实回文长度 == 扩展串第 i 个位置的回文半径 - 1

### 染色法

- 用于判断一张图是否是[[计算机基础/数据结构#二分图|二分图]]

### 二分图匹配问题

- 最大匹配：二分图 G 的所有匹配中，边数最多的匹配；可能不唯一
- 最佳匹配：带权二分图权和最大的匹配

### 最近公共祖先问题
