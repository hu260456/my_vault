### 数据的概念

- 数据元素是数据的基本单位，数据项是构成数据元素的不可分割的最小单位
- 如果一个数据项由多个细分的属性组成，这个数据项称为 `组合项`
- 数据对象：具有 `相同性质` 的数据对象的集合，是数据的一个子集
- 数据结构：一种或多种特定关系的数据元素的集合
- 数据的逻辑结构
    - 线性
    - 集合
    - 图形
    - 树形
- 数据的物理存储结构
    - 顺序
    - 链式
    - 索引
    - 散列

### 栈

- 性质
    - `卡特兰数`: n 个不同元素进栈，出栈的排列个数为 ${ 1 \over (n+1) } C_{2n}^n$
    - 中缀表达式
	    - 一个中缀表达式可能转化为多个前（后）缀表达式
    - 波兰表达式
        - 手算时右边优先计算
        - 运算符生效顺序从右到左
        - 用栈运算时从右开始扫描
    - 逆波兰表达式
        - 手算时左边优先计算
        - 运算符生效顺序从左到右
        - 用栈运算时从左开始扫描

### 二叉树

#### 性质

- 完全二叉树如果某个结点只有一个孩子，这个孩子一定是左孩子
- $n_0=n_2 +1$，即叶子结点比双分支结点多 1 个
	- $结点总数=n_0+n_1+n_2$
	- $结点总数=总度数+1=n_1+2n_2+1$
- n0 结点和 n2 结点的总和为奇数
- 若完全二叉树有 2k(偶数) 个结点，则有 $n_1=1, n_0=k, n_2=k-1$
- 若完全二叉树有 2k-1(奇数) 个结点，则有 $n_1=0, n_0=k, n_2=k-1$
- 有 n 个结点的完全二叉树的高度 h 为 $\log_2(n+1)$`向上取整` 或 $\log_2n$`向下取整 + 1`
- 第 i 个结点所在层次为 $\log_2(n+1)$`向上取整` 或 $\log_2i$`向下取整 + 1`
- 完全二叉树最多只有一个度为 1 的结点
- n 个结点的二叉树有 n + 1 个空链域

#### 遍历方式

- 前序遍历
- 中序遍历
- 后序遍历
- 层次遍历
- **morris 遍历**

#### 堆

- 是完全二叉树
- 操作
    - 建堆
    - 向下调整
    - 向上调整
    - 插入
        - 先插入表尾
        - 向上调整
        - 向下调整
    - 删除

#### 队列

##### 优先级队列

- 内部实现为堆
- TC(入队, 出队) = logn
- 不支持删除指定元素，只能删除堆顶
- 构造函数: `priority_queue<Type, Container, Functional>`
- 当元素是基本类型时可以只传递模板类型 `Type`
- 操作
	- top: 访问队头元素，即堆顶
	- empty: 判空
	- size: 返回队伍长度
	- push: 将元素插入到队尾并排序
	- emplace: 原地构造一个元素并插入队列
	- pop: 弹出队头元素
	- swap: 交换内容

#### Treap

- treap 拥有 BST 和 堆的性质
- 分类
	- 有旋 Treap
	- 无旋 Treap
		- 结点定义:
```CPP
struct Node {
	Node *left, *right; // 左右结点
	int val; // 结点值
	int rank; // 当前结点的排名
	int size; // 以当前结点为根的子树的大小
	int rep_cnt; //
}
```

#### AVL树

- 节点的平衡因子：左子树高度 - 右子树高度
- 基本操作
    - 左旋
    - 右旋
- 调整最小不平衡子树来保持整棵二叉树的平衡
- 可能需要多次调整，需要多次向上检查平衡因子

#### 线段树

- 是一种特殊的平衡二叉搜索树
- 通常用数组存储，最多需要 4n-5 的空间，一般开 4n 的空间
- 父节点表示区间 `[a, b]`
- 左孩子表示区间 `[a, (a+b)/2]`
- 右孩子表示区间 `[(a+b)/2+1, b]`
- 叶节点 a == b
- 叶节点个数 = b - a + 1

#### 树状数组

- 设原始数组 n, 树状数组 m, 前缀和 `s[i]`
- m 和 n 元素个数相等，树状数组所有层第偶数个元素都是没用的
- 可以看作线段树的阉割版
- `m[i]` 管理的区间个数是 lowbit(i)
- 所有倒数第 n 行的结点，他们的 lowbit(结点编号) 均为 n
- `m[i]` 的直接前驱为 `m[i - lowbit(i)]`
- `m[i]` 的父节点为 `m[i + lowbit(i)]`
- 求 `s[i]` 步骤
	1. int res = 0
	2. res += `m[i]`
	3. res += `m[i的所有前驱结点]`
- 修改 `n[i]` 步骤
	1. `n[i]` = val
	2. `m[i]` += val
	3. `m[i的所有祖先]` += val

#### ST 表（sparse-table）

- 主要用于解决区间维护问题
- 预处理
	1. 
- 查询

#### B 树

- 是一颗 m叉树，称 m 为 B树的`阶(度)`
- 4阶B树被称为 `2-3-4树`
- 一个结点最多有 m-1 个关键字, m 棵子树
- 除根节点，其他节点至少有 m/2(向上取整)-1 个关键字，m/2(向上取整) 棵子树
- 若根节点不是叶子结点，其至少有2个孩子
- 所有叶节点都在同一层上
- n 个关键字的B树有 n+1 个外部节点
- 任何节点的子树高度相同
- 结点结构
    - n: 记录结点关键字个数
    - $K_n$: 第n个关键字, 其中 $K_0$即上式 n
    - $P_n$: 结点第n个孩子的指针

#### B+ 树

- 非叶结点不存储数据
- 叶子结点只存储数据，所有的叶节点包含了全部的关键字
- 结点的子树个数 = 关键字个数

#### 红黑树

- 本质上是 `2-3-4 树`，即 `4阶B树`
- 根节点为黑色
- 叶(外部)节点为黑色
- 不存在连续的红色节点
- 对于任意节点，到所有叶(外部)节点的路径包含的黑色节点数都相同
- 节点的黑高bh = 该节点到达任意外部节点路径上的黑色节点总数
- 从根节点到外部节点的最长路径 ≤ 最短路径 * 2
- 红黑树高度h ≤ $2log_2(n+1)$, n是内部节点个数
- 结点插入规则
    - 空树插入黑色结点，非空树插入红色结点
    - 如果插入后红黑树被破环
        - 当叔叔为黑，旋转爷爷，LL/RR时爷爷父亲取反色，LR/RL时爷爷自己取反色
        - 当叔叔为红，叔父爷取反色，并将爷爷视为新结点
- 结点删除规则

#### 线索二叉树

- 结点的空链域可以用来记录各种遍历的前驱、后继的信息
- 指向前驱、后继的指针称为“线索”
- 结点增加 ltag, rtag变量 来标志结点指针是线索还是孩子指针
- 先序线索二叉树不能找前驱，后继线索二叉树不能找后继，除非使用三叉链表或者从根开始遍历寻找
- 中序线索二叉树可以找前驱和后继

#### 哈夫曼树

- 带权路径长度(WPL)最小的二叉树，也称`最优二叉树`
- 不存在 $n_1$ 结点
- 节点总数 $n = 2n_0 - 1 = 2n_2 + 1$
- 可能不唯一，但 WPL 一定相同

### 多叉树

- 性质
    - m 叉树第 i 层至多有 $m^{i-1}$ 个结点
    - 具有 n 个结点的 m 叉树的最小高度为 $\log_m(n(m-1)+1)$向上取整
- 树的存储结构
    - 双亲表示法 → 类似于静态链表
    - 孩子表示法
    - 双亲孩子表示法 → 数组内存放由数据、父节点下标、孩子节点下标链表指针构成的结构体
    - 孩子兄弟表示法
        - 转化为二叉树再存储，对森林也适用
        - 设原树（森林）为T，转化后的二叉树为 T'，有：
            T的先序序列 = T'的先序序列
            T不存在中序序列
            T的后序序列 = T'的中序序列

### Trie

- todo

### 树套树

- todo

### 哈希表

- 由 `直接寻址表` 和 `哈希函数` 组成
- Addr = H(Key)，输入 Key，输出存储索引
- 通常的操作 `insert`, `find`, `erase`
- 装填因子 $\alpha$ = 记录个数 / 散列表长度

#### 常见的哈希函数

- 除法哈希
	- H(k) = k % p
	- 表长为 m 时，p 取不大于 m 但最接近 m 的质数
- 乘法哈希
- 全域哈希

#### 哈希冲突解决方案

- 开放地址法
    - 线性探测：如果位置 i 被占用，则探查 i+1, i+2 ...
    - 二次探测：如果位置 i 被占用，则探查 $i+1^2, i-1^2, i+2^2...$
	    - 表长是可以表示成 4j+3 的素数, 才能探测到所有位置
    - 随机序列法
	    - 定义一个随机序列，根据这个序列来探查下一个可用空间
- 拉链法
- 再散列法
    使用 H0(k) 发生冲突时，采用 H1(k), H2(k)...

### 图

#### 性质

- $|V|$ 表示图 G 中顶点的个数，也称图 G 的阶
- 无向图的度记为 `TD(v)`
- 有向图的入度记为 `ID(v)`、出度记为 `OD(v)`
- 顶点不重复出现的路径称为 `简单路径`
- 除了第一个和最后一个顶点外，其余顶点不重复出现的回路称为`简单回路`
- 对于 n 个顶点的**无向图 G**
    - 若 G 是连通图，则最少有 n-1 条边
    - 若 G 是非连通图，则至多有 $C^2_{n-1}$ 条边
- 对于 n 个顶点的**有向图 G**
    - 若 G 是强连通图，则最少有 n 条边（形成回路）
- `生成子图` 的 V(G) 和 原图一样，但是 E(G) 不一样
- `极大连通子图` 包含尽可能多的顶点和边
- 无向图中的 `极大连通子图` 称为 `连通分量`
- 有向图中的 `极大强连通子图` 称为 `强连通分量`
- `连通图` 的 `生成树` 是包含图中所有顶点的一个 `极小连通子图(边尽可能少)`
- `非连通图中`，连通分量的生成树构成了非连通图的 `生成森林`
- 树可以看成是不存在回路且连通的无向图
- n 个顶点的图，若 $|E|>n-1$，则一定有回路
- 一个顶点的入度为 0，其余顶点的入度均为 1 的有向图，称为 `有向树`

#### 存储方式

- 邻接矩阵
- (逆)邻接表
- 十字链表
	- 用于有向图
- 邻接多重表
	- 用于无向图

#### 操作

- 广度优先遍历
	- 根据遍历的过程可以获得 `广度优先生成树`，可能不是唯一的
- 深度优先遍历
	- 根据遍历的过程可以获得 `深度优先生成树`，可能不是唯一的
- 求最小生成树 (最小代价树)
    - Prim 算法
		从任一个结点开始构建生成树，每次将代价最小的新结点纳入生成树，直到所有结点都纳入为止
		时间复杂度：$O(|V|^2)$
		适合用于边稠密图
    - Kruskal 算法
	    每次选择一条权值最小的边，使这条边的两个结点连通，如果两个结点已连通，则跳过这条边
	    时间复杂度：$O(|E|*log_2|E|)$
	    适合用于边稀疏图
- 求最短路
    - 单源最短路
        - BFS 算法
            - 限无权图
            - 广度优先生成树节点的深度可以反映到原点的距离
        - Dijkstra 算法
            - 不适用于带负权的图
            - 属于贪心策略
    - 全源最短路
        - Floyd 算法
            - 不适用于带负权回路的图
            - 属于动态规划

#### 有向无环图(DAG)

- AOV网
    用顶点表示活动的网
    AOV网一定是有向无环图
- 拓扑排序
    从 AOV 网中选择一个没有前驱的顶点并输出
    从网中删除改顶点和所有以它为起点的有向边
    重复上述步骤直到 AOV 网为空或当前网中不存在无前驱的结点为止
- AOE网
    以结点表示事件
    以有向边表示活动
    以边上的权值表示完成活动的开销
    工程开始的结点叫源点，结束的结点叫汇点
    从源点到汇点的有向路径可能有多条
    所有从源点到汇点的路径中具有最大路径长度的路径称为 `关键路径`
    关键路径上的活动称为 `关键活动`
    时间余量 = 活动最早开始时间 - 活动最迟开始时间
    时间余量表示一个活动可以拖延的最长时间
    关键活动没有时间余量

#### 二分图

- 通常是无向图
- 一张图可以分为两个集合，每个集合的元素两两无边，此图为二分图
- 可以用[[计算机基础/算法#染色法|染色法]]判断二分图

### 集合

#### 并查集

- 是一种树形数据结构
- 表示方法
	- 森林是 m(m ≥ 0) 棵互不相交的树的集合，可以用森林来表示一个集合
	- 适合用双亲表示法存储
- 基本操作
    - 合并两个集合
    - 查询元素是否属于一个集合
- 优化
    - “小树并入大树”，减少树高，树高不超过 $log_2n$+1 (向下取整)
    - 压缩路径，树高不超过$O(\alpha(n))$，$\alpha(n)$是一个增长很慢的函数，通常不大于4，可以视作O(1)
